<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChipuRobo Path Editor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .container {
            display: flex;
            gap: 20px;
            max-width: 1600px;
            margin: 0 auto;
        }
        .canvas-container {
            background: white;
            border: 3px solid #333;
            border-radius: 10px;
            padding: 10px;
        }
        canvas {
            border: 2px solid #333;
            background: #2e7d32;
            cursor: crosshair;
        }
        .controls {
            background: white;
            border: 2px solid #333;
            border-radius: 10px;
            padding: 20px;
            width: 350px;
            height: fit-content;
        }
        .admin-controls {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }
        button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            font-size: 14px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        .save-btn { background: #4CAF50; color: white; }
        .load-btn { background: #2196F3; color: white; }
        .clear-btn { background: #f44336; color: white; }
        .field-btn { background: #ff9800; color: white; }
        .mode-btn { background: #9c27b0; color: white; }
        .active-mode { background: #4caf50 !important; }
        
        .mode-selector {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .mode-selector button {
            width: auto;
            padding: 8px 12px;
            margin: 0;
            font-size: 12px;
        }
        
        .waypoint-list {
            background: #f9f9f9;
            border: 1px solid #ccc;
            border-radius: 5px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .field-elements {
            background: #f3e5f5;
            border: 1px solid #9c27b0;
            border-radius: 5px;
            padding: 10px;
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
        }
        .instructions {
            background: #e3f2fd;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 20px;
        }
        .status {
            background: #fff3e0;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-weight: bold;
            color: #e65100;
        }
        .dimension-input {
            display: flex;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .dimension-input input {
            width: 80px;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
        }
        .field-info {
            background: #e8f5e8;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <h1>ü§ñ ChipuRobo Path Editor</h1>
    
    <div class="instructions">
        <strong>üèüÔ∏è FIRST Robotics Style Field Designer & Path Planner</strong>
        <ul>
            <li><strong>Admin Mode:</strong> Design field with obstacles, scoring zones, and starting positions</li>
            <li><strong>Path Mode:</strong> Click on the field to create robot navigation waypoints</li>
            <li>Field dimensions are configurable (default: 16.5ft x 8.2ft like FRC field)</li>
            <li>Export/import field configurations and paths separately</li>
        </ul>
    </div>

    <div class="container">
        <div class="canvas-container">
            <canvas id="pathCanvas" width="1000" height="600"></canvas>
        </div>
        
        <div class="controls">
            <div class="admin-controls">
                <h3>üîß Admin Field Designer</h3>
                
                <div class="field-info">
                    <strong>Field Dimensions:</strong><br>
                    <div class="dimension-input">
                        Width: <input type="number" id="fieldWidth" value="16.5" step="0.1"> ft
                    </div>
                    <div class="dimension-input">
                        Height: <input type="number" id="fieldHeight" value="8.2" step="0.1"> ft
                    </div>
                    <button class="field-btn" onclick="updateFieldSize()">üìè Update Field Size</button>
                </div>
                
                <div class="mode-selector">
                    <button class="mode-btn active-mode" onclick="setMode('waypoint', event)">üéØ Path</button>
                    <button class="mode-btn" onclick="setMode('obstacle', event)">üöß Obstacle</button>
                    <button class="mode-btn" onclick="setMode('zone', event)">üé™ Zone</button>
                    <button class="mode-btn" onclick="setMode('start', event)">üöÄ Start</button>
                </div>
                
                <button class="save-btn" onclick="saveField()">üíæ Save Field</button>
                <button class="load-btn" onclick="loadField()">üìÅ Load Field</button>
                <button class="clear-btn" onclick="clearField()">üóëÔ∏è Clear Field</button>
            </div>
            
            <div class="admin-controls" style="background: #e8f5e8; border: 2px solid #4caf50;">
                <h3>ü§ñ Robot Configuration</h3>
                
                <div class="field-info">
                    <strong>Physical Parameters:</strong><br>
                    <div class="dimension-input">
                        Length: <input type="number" id="robotLength" value="1.0" step="0.1" title="Robot length in feet"> ft
                    </div>
                    <div class="dimension-input">
                        Width: <input type="number" id="robotWidth" value="0.8" step="0.1" title="Robot width in feet"> ft
                    </div>
                    <div class="dimension-input">
                        Wheel Diameter: <input type="number" id="wheelDiameter" value="4.0" step="0.1" title="Wheel diameter in inches"> in
                    </div>
                    <div class="dimension-input">
                        Wheelbase: <input type="number" id="wheelbase" value="8.0" step="0.1" title="Distance between wheels in inches"> in
                    </div>
                    
                    <strong>Motion Limits (Raspberry Pi + DC Motors):</strong><br>
                    <div class="dimension-input">
                        Max Speed: <input type="number" id="maxSpeed" value="3.0" step="0.1" title="Maximum speed in ft/s"> ft/s
                    </div>
                    <div class="dimension-input">
                        Max Accel: <input type="number" id="maxAccel" value="2.0" step="0.1" title="Maximum acceleration in ft/s¬≤"> ft/s¬≤
                    </div>
                    <div class="dimension-input">
                        PWM Frequency: <input type="number" id="pwmFreq" value="1000" step="100" title="L298N PWM frequency in Hz"> Hz
                    </div>
                    
                    <strong>System Status:</strong><br>
                    <div class="dimension-input" style="color: #666; font-style: italic;">
                        Server: Running locally on this Raspberry Pi
                        <input type="text" id="robotIP" value="localhost" readonly style="background: #f0f0f0; color: #666; width: 100px;">
                    </div>
                    <div class="dimension-input" style="display: none;">
                        SSH User: <input type="text" id="sshUser" value="pi" placeholder="SSH username" title="SSH username for Pi">
                    </div>
                    <button class="field-btn" onclick="testConnection()">üîó Test Robot Status</button>
                </div>
                
                <button class="save-btn" onclick="deployToRobot()">üöÄ Deploy to Robot</button>
                <button class="load-btn" onclick="saveConfig()">üíæ Save Config</button>
                <button class="field-btn" onclick="loadConfig()">üìÅ Load Config</button>
            </div>
            
            <h3>Path Controls</h3>
            <button class="save-btn" onclick="savePath()">üíæ Save Path</button>
            <button class="load-btn" onclick="loadPath()">üìÅ Load Path</button>
            <button class="clear-btn" onclick="clearPath()">üóëÔ∏è Clear Path</button>
            
            <h3>Field Elements</h3>
            <div class="field-elements" id="fieldElements">
                No field elements yet.
            </div>
            
            <h3>Waypoints</h3>
            <div class="waypoint-list" id="waypointList">
                No waypoints yet.
            </div>
            
            <div class="status" id="status">
                Admin Mode: Click mode buttons above, then click on field to place elements.
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('pathCanvas');
        const ctx = canvas.getContext('2d');
        const waypointList = document.getElementById('waypointList');
        const fieldElementsList = document.getElementById('fieldElements');
        const status = document.getElementById('status');
        
        let waypoints = [];
        let fieldElements = [];
        let currentMode = 'waypoint';
        let fieldWidth = 16.5; // feet
        let fieldHeight = 8.2; // feet
        let pixelsPerFoot = 60; // Scale: 60 pixels per foot

        // Draw field background and grid
        function drawField() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Field background (FRC carpet green)
            ctx.fillStyle = '#2e7d32';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Field boundary (white lines)
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.strokeRect(20, 20, fieldWidth * pixelsPerFoot, fieldHeight * pixelsPerFoot);
            
            // Grid lines (1 foot intervals)
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            
            // Vertical lines (every foot)
            for (let i = 1; i < fieldWidth; i++) {
                const x = 20 + i * pixelsPerFoot;
                ctx.beginPath();
                ctx.moveTo(x, 20);
                ctx.lineTo(x, 20 + fieldHeight * pixelsPerFoot);
                ctx.stroke();
            }
            
            // Horizontal lines (every foot)
            for (let i = 1; i < fieldHeight; i++) {
                const y = 20 + i * pixelsPerFoot;
                ctx.beginPath();
                ctx.moveTo(20, y);
                ctx.lineTo(20 + fieldWidth * pixelsPerFoot, y);
                ctx.stroke();
            }
            
            // Field center line
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            const centerX = 20 + (fieldWidth * pixelsPerFoot) / 2;
            ctx.beginPath();
            ctx.moveTo(centerX, 20);
            ctx.lineTo(centerX, 20 + fieldHeight * pixelsPerFoot);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw field elements
            fieldElements.forEach(element => {
                drawFieldElement(element);
            });
        }
        
        // Draw field element
        function drawFieldElement(element) {
            const x = element.x;
            const y = element.y;
            
            switch(element.type) {
                case 'obstacle':
                    ctx.fillStyle = '#8d6e63';
                    ctx.strokeStyle = '#5d4037';
                    ctx.lineWidth = 2;
                    ctx.fillRect(x - 15, y - 15, 30, 30);
                    ctx.strokeRect(x - 15, y - 15, 30, 30);
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üöß', x, y + 4);
                    break;
                    
                case 'zone':
                    ctx.strokeStyle = '#ff5722';
                    ctx.fillStyle = 'rgba(255, 87, 34, 0.3)';
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 25, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('üé™', x, y + 5);
                    break;
                    
                case 'start':
                    ctx.strokeStyle = '#4caf50';
                    ctx.fillStyle = 'rgba(76, 175, 80, 0.8)';
                    ctx.lineWidth = 3;
                    
                    // Draw arrow pointing up
                    ctx.beginPath();
                    ctx.moveTo(x, y - 20);
                    ctx.lineTo(x - 15, y + 10);
                    ctx.lineTo(x - 5, y + 10);
                    ctx.lineTo(x - 5, y + 20);
                    ctx.lineTo(x + 5, y + 20);
                    ctx.lineTo(x + 5, y + 10);
                    ctx.lineTo(x + 15, y + 10);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    ctx.fillStyle = 'white';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('START', x, y + 5);
                    break;
            }
        }

        // Draw waypoint
        function drawWaypoint(x, y, index) {
            // Draw circle
            ctx.fillStyle = '#ff4444';
            ctx.strokeStyle = '#aa0000';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            
            // Draw number
            ctx.fillStyle = 'white';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText((index + 1).toString(), x, y + 5);
        }

        // Draw line with arrow
        function drawArrowLine(x1, y1, x2, y2) {
            ctx.strokeStyle = '#4444ff';
            ctx.lineWidth = 4;
            
            // Draw line
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            // Draw arrow head
            const angle = Math.atan2(y2 - y1, x2 - x1);
            const arrowLength = 15;
            const arrowAngle = Math.PI / 6;
            
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle - arrowAngle),
                y2 - arrowLength * Math.sin(angle - arrowAngle)
            );
            ctx.moveTo(x2, y2);
            ctx.lineTo(
                x2 - arrowLength * Math.cos(angle + arrowAngle),
                y2 - arrowLength * Math.sin(angle + arrowAngle)
            );
            ctx.stroke();
        }

        // Redraw canvas
        function redraw() {
            drawField();
            
            // Draw path lines first
            for (let i = 1; i < waypoints.length; i++) {
                drawArrowLine(
                    waypoints[i-1].x, waypoints[i-1].y,
                    waypoints[i].x, waypoints[i].y
                );
            }
            
            // Draw waypoints on top
            waypoints.forEach((point, index) => {
                drawWaypoint(point.x, point.y, index);
            });
        }

        // Update waypoint list
        function updateWaypointList() {
            if (waypoints.length === 0) {
                waypointList.innerHTML = 'No waypoints yet.';
                return;
            }
            
            waypointList.innerHTML = waypoints
                .map((point, index) => {
                    const fieldX = ((point.x - 20) / pixelsPerFoot).toFixed(1);
                    const fieldY = (fieldHeight - (point.y - 20) / pixelsPerFoot).toFixed(1);
                    return `<div>WP${index + 1}: (${fieldX}ft, ${fieldY}ft)</div>`;
                })
                .join('');
        }
        
        // Update field elements list
        function updateFieldElementsList() {
            if (fieldElements.length === 0) {
                fieldElementsList.innerHTML = 'No field elements yet.';
                return;
            }
            
            fieldElementsList.innerHTML = fieldElements
                .map((element, index) => {
                    const fieldX = ((element.x - 20) / pixelsPerFoot).toFixed(1);
                    const fieldY = (fieldHeight - (element.y - 20) / pixelsPerFoot).toFixed(1);
                    const icon = element.type === 'obstacle' ? 'üöß' : element.type === 'zone' ? 'üé™' : 'üöÄ';
                    return `<div>${icon} ${element.type}: (${fieldX}ft, ${fieldY}ft)</div>`;
                })
                .join('');
        }

        // Canvas click handler
        canvas.addEventListener('click', function(event) {
            const rect = canvas.getBoundingClientRect();
            const x = Math.round(event.clientX - rect.left);
            const y = Math.round(event.clientY - rect.top);
            
            // Check if click is within field boundaries
            if (x < 20 || x > 20 + fieldWidth * pixelsPerFoot || 
                y < 20 || y > 20 + fieldHeight * pixelsPerFoot) {
                status.textContent = 'Please click within the field boundaries (white rectangle)';
                return;
            }
            
            if (currentMode === 'waypoint') {
                waypoints.push({x, y});
                updateWaypointList();
                
                // Convert to field coordinates (feet from bottom-left)
                const fieldX = ((x - 20) / pixelsPerFoot).toFixed(1);
                const fieldY = (fieldHeight - (y - 20) / pixelsPerFoot).toFixed(1);
                status.textContent = `Added waypoint ${waypoints.length} at field position (${fieldX}ft, ${fieldY}ft)`;
            } else {
                // Add field element
                const element = {
                    type: currentMode,
                    x: x,
                    y: y,
                    id: Date.now()
                };
                fieldElements.push(element);
                updateFieldElementsList();
                
                const fieldX = ((x - 20) / pixelsPerFoot).toFixed(1);
                const fieldY = (fieldHeight - (y - 20) / pixelsPerFoot).toFixed(1);
                status.textContent = `Added ${currentMode} at field position (${fieldX}ft, ${fieldY}ft)`;
            }
            
            redraw();
        });

        // Control functions
        function savePath() {
            if (waypoints.length === 0) {
                alert('No waypoints to save!');
                return;
            }
            
            const data = JSON.stringify({points: waypoints.map(p => [p.x, p.y])}, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'robot_path.json';
            a.click();
            
            URL.revokeObjectURL(url);
            status.textContent = 'Path saved successfully!';
        }

        function loadPath() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json,.path';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        waypoints = data.points.map(p => ({x: p[0], y: p[1]}));
                        redraw();
                        updateWaypointList();
                        status.textContent = `Loaded ${waypoints.length} waypoints`;
                    } catch (error) {
                        alert('Error loading file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        function clearPath() {
            waypoints = [];
            redraw();
            updateWaypointList();
            status.textContent = 'All waypoints cleared. Click to add new ones!';
        }
        
        // Field management functions
        function setMode(mode, event) {
            currentMode = mode;
            
            // Update button styles
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active-mode');
            });
            
            // Ensure event is not null before accessing target
            if(event && event.target) {
                event.target.classList.add('active-mode');
            } else {
                // Fallback for initial load
                document.querySelector(`.mode-btn[onclick*="'${mode}'"]`).classList.add('active-mode');
            }
            
            const modeNames = {
                'waypoint': 'Path Planning',
                'obstacle': 'Obstacle Placement',
                'zone': 'Scoring Zone Placement',
                'start': 'Starting Position Placement'
            };
            
            status.textContent = `Mode: ${modeNames[mode]}. Click on the field to place elements.`;
        }
        
        function updateFieldSize() {
            fieldWidth = parseFloat(document.getElementById('fieldWidth').value);
            fieldHeight = parseFloat(document.getElementById('fieldHeight').value);
            
            // Update canvas size
            canvas.width = 40 + fieldWidth * pixelsPerFoot;
            canvas.height = 40 + fieldHeight * pixelsPerFoot;
            
            redraw();
            status.textContent = `Field updated to ${fieldWidth}ft x ${fieldHeight}ft`;
        }
        
        function saveField() {
            const fieldData = {
                dimensions: { width: fieldWidth, height: fieldHeight },
                elements: fieldElements,
                pixelsPerFoot: pixelsPerFoot
            };
            
            const data = JSON.stringify(fieldData, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'robot_field.json';
            a.click();
            
            URL.revokeObjectURL(url);
            status.textContent = 'Field configuration saved successfully!';
        }
        
        function loadField() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (data.dimensions) {
                            fieldWidth = data.dimensions.width;
                            fieldHeight = data.dimensions.height;
                            document.getElementById('fieldWidth').value = fieldWidth;
                            document.getElementById('fieldHeight').value = fieldHeight;
                        }
                        
                        if (data.pixelsPerFoot) {
                            pixelsPerFoot = data.pixelsPerFoot;
                        }
                        
                        fieldElements = data.elements || [];
                        
                        // Update canvas size
                        canvas.width = 40 + fieldWidth * pixelsPerFoot;
                        canvas.height = 40 + fieldHeight * pixelsPerFoot;
                        
                        redraw();
                        updateFieldElementsList();
                        status.textContent = `Field loaded with ${fieldElements.length} elements`;
                    } catch (error) {
                        alert('Error loading field file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }
        
        function clearField() {
            if (confirm('This will clear all field elements (obstacles, zones, starting positions). Continue?')) {
                fieldElements = [];
                redraw();
                updateFieldElementsList();
                status.textContent = 'Field cleared. Only boundary and grid remain.';
            }
        }

        // Robot configuration functions
        function testConnection() {
            const robotIP = document.getElementById('robotIP').value;
            const serverURL = `http://${robotIP}:5001`;
            
            status.textContent = 'Testing robot status...';
            
            fetch(`${serverURL}/status`, {method: 'GET'})
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const hardware = data.hardware || {};
                    const robotReady = data.robot_ready || false;
                    
                    if (robotReady) {
                        status.style.color = '#4caf50';
                        status.textContent = `‚úÖ Robot Ready! Running on ${hardware.platform} with GPIO access (${data.missions_stored || 0} missions stored)`;
                    } else if (hardware.is_raspberry_pi) {
                        status.style.color = '#ff9800';
                        status.textContent = `‚ö†Ô∏è Raspberry Pi detected but GPIO issue: ${hardware.gpio_error || 'Unknown error'}`;
                    } else {
                        status.style.color = '#f44336';
                        status.textContent = `‚ùå Not a robot! Running on ${hardware.platform} - Deploy to Raspberry Pi for robot control`;
                    }
                    
                    // Update deploy button state
                    const deployBtn = document.querySelector('button[onclick="deployToRobot()"]');
                    if (deployBtn) {
                        deployBtn.disabled = !robotReady;
                        deployBtn.title = robotReady ? 'Deploy mission to robot' : 'Robot hardware not available';
                        deployBtn.style.opacity = robotReady ? '1' : '0.5';
                    }
                })
                .catch(error => {
                    status.style.color = '#f44336';
                    status.textContent = `‚ùå Server connection failed: ${error.message}`;
                });
        }
        
        function deployToRobot() {
            const robotIP = document.getElementById('robotIP').value;
            
            // First check if robot hardware is ready
            status.textContent = 'Checking robot status before deployment...';
            
            fetch(`http://${robotIP}:5001/status`)
                .then(response => response.json())
                .then(statusData => {
                    if (!statusData.robot_ready) {
                        const hardware = statusData.hardware || {};
                        if (hardware.is_raspberry_pi) {
                            status.style.color = '#ff9800';
                            status.textContent = `‚ö†Ô∏è Cannot deploy: GPIO error on Pi - ${hardware.gpio_error}`;
                        } else {
                            status.style.color = '#f44336';
                            status.textContent = `‚ùå Cannot deploy: Not running on Raspberry Pi (detected: ${hardware.platform})`;
                        }
                        return;
                    }
                    
                    // Robot is ready, proceed with deployment
                    const deployData = {
                        field: {
                            dimensions: { width: fieldWidth, height: fieldHeight },
                            elements: fieldElements,
                            pixelsPerFoot: pixelsPerFoot
                        },
                        path: {
                            waypoints: waypoints.map(wp => {
                                const fieldX = (wp.x - 20) / pixelsPerFoot;
                                const fieldY = fieldHeight - (wp.y - 20) / pixelsPerFoot;
                                return { x: fieldX, y: fieldY };
                            })
                        },
                        robotConfig: {
                            length: parseFloat(document.getElementById('robotLength').value),
                            width: parseFloat(document.getElementById('robotWidth').value),
                            wheelDiameter: parseFloat(document.getElementById('wheelDiameter').value),
                            wheelbase: parseFloat(document.getElementById('wheelbase').value),
                            maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                            maxAccel: parseFloat(document.getElementById('maxAccel').value),
                            pwmFreq: parseFloat(document.getElementById('pwmFreq').value),
                            platform: 'raspberry_pi',
                            motorDriver: 'l298n',
                            sshUser: document.getElementById('sshUser').value
                        },
                        timestamp: new Date().toISOString()
                    };
                    
                    status.textContent = 'Deploying mission to robot...';
                    
                    return fetch(`http://${robotIP}:5001/deploy`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(deployData)
                    });
                })
                .then(response => {
                    if (response) return response.json();
                })
                .then(data => {
                    if (data) {
                        status.style.color = '#4caf50';
                        status.textContent = `üöÄ Mission deployed successfully! Mission ID: ${data.missionId}`;
                    }
                })
                .catch(error => {
                    status.style.color = '#f44336';
                    status.textContent = `‚ùå Deployment failed: ${error.message}`;
                });
        }
        
        function saveConfig() {
            const config = {
                robot: {
                    length: parseFloat(document.getElementById('robotLength').value),
                    width: parseFloat(document.getElementById('robotWidth').value),
                    wheelDiameter: parseFloat(document.getElementById('wheelDiameter').value),
                    wheelbase: parseFloat(document.getElementById('wheelbase').value),
                    maxSpeed: parseFloat(document.getElementById('maxSpeed').value),
                    maxAccel: parseFloat(document.getElementById('maxAccel').value),
                    pwmFreq: parseFloat(document.getElementById('pwmFreq').value),
                    platform: 'raspberry_pi',
                    motorDriver: 'l298n',
                    ip: document.getElementById('robotIP').value,
                    sshUser: document.getElementById('sshUser').value
                },
                field: {
                    dimensions: { width: fieldWidth, height: fieldHeight },
                    pixelsPerFoot: pixelsPerFoot
                }
            };
            
            const data = JSON.stringify(config, null, 2);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = 'robot_config.json';
            a.click();
            
            URL.revokeObjectURL(url);
            status.textContent = 'Robot configuration saved successfully!';
        }
        
        function loadConfig() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = function(event) {
                const file = event.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const config = JSON.parse(e.target.result);
                        
                        if (config.robot) {
                            document.getElementById('robotLength').value = config.robot.length || 1.0;
                            document.getElementById('robotWidth').value = config.robot.width || 0.8;
                            document.getElementById('wheelDiameter').value = config.robot.wheelDiameter || 4.0;
                            document.getElementById('wheelbase').value = config.robot.wheelbase || 8.0;
                            document.getElementById('maxSpeed').value = config.robot.maxSpeed || 3.0;
                            document.getElementById('maxAccel').value = config.robot.maxAccel || 2.0;
                            document.getElementById('pwmFreq').value = config.robot.pwmFreq || 1000;
                            document.getElementById('robotIP').value = config.robot.ip || 'raspberrypi.local';
                            document.getElementById('sshUser').value = config.robot.sshUser || 'pi';
                        }
                        
                        if (config.field && config.field.dimensions) {
                            fieldWidth = config.field.dimensions.width;
                            fieldHeight = config.field.dimensions.height;
                            document.getElementById('fieldWidth').value = fieldWidth;
                            document.getElementById('fieldHeight').value = fieldHeight;
                            
                            if (config.field.pixelsPerFoot) {
                                pixelsPerFoot = config.field.pixelsPerFoot;
                            }
                            
                            updateFieldSize();
                        }
                        
                        status.textContent = 'Robot configuration loaded successfully!';
                    } catch (error) {
                        alert('Error loading config file: ' + error.message);
                    }
                };
                reader.readAsText(file);
            };
            
            input.click();
        }

        // Initialize field
        updateFieldSize();
        status.textContent = 'Admin Mode: Select a mode above, then click on the field to place elements.';
    </script>
</body>
</html>